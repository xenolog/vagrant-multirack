{{$hostname := getenv "HOSTNAME" }}## hostname: {{$hostname}}
{{$local_ipaddr := getv (printf "/nodes/%s/ipaddr/0" $hostname) }}## local_ipaddr: {{$local_ipaddr}}
{{$local_asnum := getv "/racks/0/as_number"}}## local_asnum: {{$local_asnum}}

# Configure logging
#log syslog { debug, trace, info, remote, warning, error, auth, fatal, bug };
log stderr all;

# Override router ID
router id {{$local_ipaddr}};

# listen bgp address {{$local_ipaddr}} port <<node_bgp_port>>;
{{range $i := ls (printf "/nodes/%s/ipaddr" $hostname)}} 
listen bgp address {{getv (printf "/nodes/%s/ipaddr/%s" $hostname $i)}};
{{- end -}}

# filter exported_by_bgp {
#   if ( (ifname ~ "tap*") || (ifname ~ "cali*") || (ifname ~ "dummy1") || (ifname ~ "lo")) then {
#     if net != 0.0.0.0/0 then accept;
#   }
#   reject;
# }

# Turn on global debugging of all protocols
debug protocols all;

protocol kernel {
  learn;          # Learn all alien routes from the kernel
  persist;        # Don't remove routes on bird shutdown
  scan time 2;    # Scan kernel routing table every 2 seconds
  import all;
  export all;     # Default is export none
  merge paths;    # For ECMP in routing table
  graceful restart;
}

protocol direct {
   debug all;
   interface "-docker*", "*";
  #check link yes;
}

# This pseudo-protocol watches all interface up/down events.
protocol device {
  scan time 2;    # Scan interfaces every 2 seconds
}


# sessions with TORs
{{range $r := lsdir "/racks"}} 
  {{ if ne $r "0" }} 
protocol bgp 'TOR-{{$r}}' {
  local as {{$local_asnum}};
  neighbor {{getv (printf "/racks/%s/tor" $r)}} as {{$local_asnum}};
  description "TOR-{{$r}}";
  import all;
  export all;
  add paths;     # For ECMP in BGP session with TOR
  next hop self;
}
  {{- end -}}
{{- end -}}

###